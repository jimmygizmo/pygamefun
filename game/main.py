#! /usr/bin/env -vS python

import config as cfg
import entity as ent
import sys
import os.path
from typing import TypedDict
import pygame
import random
import resizer


# ###########################################    GLOBAL INITIALIZATION    ##############################################

# SURFACE CACHE - 'SCACHE'
# The Surface Cache SCACHE pre-loads images into surfaces. When sprites are instantiated, they will use this cache
# for surfaces and not need to load them from disk. This is important for dynamically/frequently spawned/destroyed sprites.
SurfCacheItem = TypedDict('SurfCacheItem',
    {
        'surface_l': pygame.Surface,  # Image as loaded and with 'flip' options and/or 'resize' options applied if True. Should be LEFT facing.
        'surface_r': pygame.Surface,  # Flipped (assumed to be RIGHT-facing) version of image. Generated by load_image()
    }
)  # SurfCacheitem
SCACHE: dict[str, SurfCacheItem] = {}  # The Surface Cache. Key = filename, Value = SurfCacheItem.


# #############################################    CLASS DEFINITIONS    ################################################

class Entity(pygame.sprite.Sprite):
    base_instance_count: int = 0
    def __init__(self,
                groups,
                img_filename: str,
                x: float,
                y: float,
                direction: pygame.math.Vector2,
                speed: float,
            ):
        self.base_instance_id: int = Entity.base_instance_count
        self.surface_l: pygame.Surface = SCACHE[img_filename]['surface_l']
        self.surface_r: pygame.Surface = SCACHE[img_filename]['surface_r']
        self.x: float = x
        self.y: float = y
        self.dir: pygame.math.Vector2 = direction  # Direction
        self.speed: float = speed  # Speed
        self.image: pygame.Surface = pygame.Surface((0, 0))  # Active image (depending on direction of motion)
        self.rect: pygame.FRect = pygame.FRect()
        super().__init__(groups)  # super.update() could be done first before setting all the self.* but for now I have them last.
        Entity.base_instance_count += 1

        self.rect = self.surface_l.get_frect(center=(self.x, self.y))

    def update(self, delta_time: float, ephase_name: str):
        # NOTE: ephase_name ARG had to be added to places it is not actually used. (* PyCharm static analysis warning *)

        delta_vector = self.dir * self.speed * delta_time
        # MYPY ERROR HERE - TRICKY ONE:
        # main.py:365: error: Incompatible types in assignment (expression has type "Vector2",
        #     variable has type "tuple[float, float]")  [assignment]
        self.rect.center += delta_vector
        # ***************************

        self.physics_outer_walls()  # Handle bouncing off walls. NOTE: Props override this and pass. Props ignore walls.

        # Activate the correctly-facing image, based on X direction.
        if self.dir.x < 0:
            self.image = self.surface_l
        else:
            self.image = self.surface_r

    def physics_outer_walls(self):
        # Bounce off LEFT wall in X Axis
        if self.rect.left <= 0:
            self.rect.left = 0
            self.dir.x *= -1

        # Bounce off RIGHT wall in X Axis
        if self.rect.right >= cfg.SCREEN_WIDTH:
            self.rect.right = cfg.SCREEN_WIDTH
            self.dir.x *= -1

        # Bounce off TOP wall in Y Axis
        if self.rect.top <= 0:
            self.rect.top = 0
            self.dir.y *= -1

        # Bounce off BOTTOM wall in Y Axis
        if self.rect.bottom >= cfg.SCREEN_HEIGHT:
            self.rect.bottom = cfg.SCREEN_HEIGHT
            self.dir.y *= -1


class Player(Entity):
    instance_count: int = 0
    def __init__(self,
                groups,
                img_filename: str,
                weapon_spec: ent.WeaponSpec,
                all_weapons_group_ref: pygame.sprite.Group,
                x: float,
                y: float,
                direction: pygame.math.Vector2,
                speed: float,
            ):
        self.instance_id: int = Player.instance_count
        self.weapon_spec = weapon_spec
        self.all_weapons_group_ref = all_weapons_group_ref  # TODO: On the fence about keeping this. Should minimize global usage though, so this might be good.
        self.can_shoot: bool = True
        self.laser_shoot_time: int = 0
        self.cooldown_duration: int = cfg.LASER_COOLDOWN_DURATION  # milliseconds
        super().__init__(groups, img_filename, x, y, direction, speed)  # super.update() could be done first before setting all the self.* but for now I have them last.
        Player.instance_count += 1

    def laser_timer(self):
        if not self.can_shoot:
            current_time = pygame.time.get_ticks()  # Milliseconds since pygame.init() was called.
            if current_time - self.laser_shoot_time >= self.cooldown_duration:
                self.can_shoot = True

    def update(self, delta_time: float, ephase_name: str):
        enviro_influence(self, ephase_name)

        keys = pygame.key.get_pressed()
        recent_keys = pygame.key.get_just_pressed()

        self.dir.x = int(keys[pygame.K_RIGHT]) - int(keys[pygame.K_LEFT])
        self.dir.y = int(keys[pygame.K_DOWN]) - int(keys[pygame.K_UP])

        self.dir = self.dir.normalize() if self.dir else self.dir

        if recent_keys[pygame.K_SPACE] and self.can_shoot:
            self.can_shoot = False
            self.laser_shoot_time = pygame.time.get_ticks()
            weapon_img_filename = self.weapon_spec['img_filename']
            projectile: Weapon = Weapon(
                    groups=[all_sprites, self.all_weapons_group_ref],
                    img_filename=weapon_img_filename,
                    x=self.rect.midtop[0],
                    y=self.rect.midtop[1],
                    direction=self.weapon_spec['d'],
                    speed=self.weapon_spec['s'],
                )  # PyCharm FALSE WARNING HERE (AbstractGroup)
        self.laser_timer()
        # NOTE: WE UPDATE BASED ON INPUT --BEFORE-- WE CHECK FOR WALL COLLISION/BOUNCING (in super/Entity).
        super().update(delta_time, ephase_name)


class Weapon(Entity):
    instance_count: int = 0
    def __init__(self,
                groups,
                img_filename: str,
                x: float,
                y: float,
                direction: pygame.math.Vector2,
                speed: float,
            ):
        self.instance_id: int = Weapon.instance_count
        super().__init__(groups, img_filename, x, y, direction, speed)  # super.update() could be done first before setting all the self.* but for now I have them last.
        Weapon.instance_count += 1

    def update(self, delta_time: float, ephase_name: str):
        enviro_influence(self, ephase_name)
        super().update(delta_time, ephase_name)

    def physics_outer_walls(self):  # Overrides Entity.physics_outer_walls().
        # Projectiles/weapons are deleted beyond some margin and do not bounce off the outer walls.
        if self.rect.left <= 0 - cfg.PROJECTILE_MARGIN:  # A little beyond LEFT wall in X Axis
            self.kill()
        if self.rect.right >= cfg.SCREEN_WIDTH + cfg.PROJECTILE_MARGIN:  # A little beyond RIGHT wall in X Axis
            self.kill()
        if self.rect.top <= 0 - cfg.PROJECTILE_MARGIN:  # A little beyond TOP wall in Y Axis
            self.kill()
        if self.rect.bottom >= cfg.SCREEN_HEIGHT + cfg.PROJECTILE_MARGIN:  # A little beyond BOTTOM wall in Y Axis
            self.kill()


class Npc(Entity):
    instance_count: int = 0
    def __init__(self,
                groups,
                img_filename: str,
                x: float,
                y: float,
                direction: pygame.math.Vector2,
                speed: float,
            ):
        self.instance_id: int = Npc.instance_count
        super().__init__(groups, img_filename, x, y, direction, speed)  # super.update() can be done before or after setting any self.* but think about how it might matter! Maybe not at all.
        Npc.instance_count += 1

    def update(self, delta_time: float, ephase_name: str):
        enviro_influence(self, ephase_name)
        super().update(delta_time, ephase_name)


class Prop(Entity):
    instance_count: int = 0
    def __init__(self,
                groups,
                img_filename: str,
                x: float,
                y: float,
            ):
        self.instance_id: int = Prop.instance_count
        prop_zero_direction: pygame.math.Vector2 = pygame.math.Vector2(0, 0)  # Props special case direction, to init Entity.
        prop_zero_speed: float = 0.0  # Props special case speed, to init Entity.
        super().__init__(groups, img_filename, x, y, prop_zero_direction, prop_zero_speed)  # super.update() can be done before or after setting any self.* but think about how it might matter! Maybe not at all.
        Prop.instance_count += 1

    def update(self, delta_time: float, ephase_name: str):
        super().update(delta_time, ephase_name)

    def physics_outer_walls(self):  # Overrides Entity.physics_outer_walls, so we can disable that for Props.
        pass


# #############################################    FUNCTION DEFINITIONS    #############################################

# NOTE: Disabling enviro_influence temporarily for many reasons:
# 1. I have removed spec from instances and this was where new enviro speeds are stored. I need to pass another way now.
# 2. I want to generalize so I need a tiny macro language to instruct enviro response changes to ANY ATTRIBUTE.
# 3. This macro system needs to be super simple and process efficiently OR just pass a simpler dict than spec.
# 4. Or use callbacks to little functions which implement the enviro responses.
# 5. When this is figured out I will re-enable the new form. None of this is in the tutorial anyhow.
# *** MyPy ERROR about PropSpec dict has no keys for p,r,c,f - BUT PropSpec WILL **NEVER** BE PASSED HERE !!! ???
def enviro_influence(xself: Player | Weapon | Npc, ephase_name: str) -> None:
    pass  # TEMPORARILY DISABLED PER THE ABOVE REASONS.
    # # ENVIRO PHASES - APPLICATION OF INFLUENCE OF CURRENT PHASE
    # if ephase_name == 'peace':
    #     xself.speed = xself.spec['p']
    # elif ephase_name == 'rogue':
    #     xself.speed = xself.spec['r']
    # elif ephase_name == 'chaos':
    #     xself.speed = xself.spec['c']
    # elif ephase_name == 'frozen':
    #     xself.speed = xself.spec['f']
    # else:
    #     raise ValueError(f"FATAL: Invalid ephase_name '{ephase_name}'. "
    #                      "Check values in ENVIRO_PHASES config.")

def load_image(
            filename: str,
            flip: bool,
            resize: bool,
            width: int | None,
            height: int | None,
        ) -> None:
    image_path = os.path.join(cfg.ASSET_PATH, filename)
    surface_l: pygame.Surface = pygame.Surface((0, 0))
    if resize:
        if width and height:
            with open(image_path, 'rb') as fh:
                img_bytes = fh.read()
            resized_png_bytes = resizer.alphonic_resize(
                    img_data=img_bytes,
                    width=width,
                    height=height,
                )
            # Output of this file was originally for validation, and now it is a workaround until frombytes() works.
            with open('load-image-temp-out-png.png', 'wb') as fh:
                fh.write(resized_png_bytes)
            # This image data is good! Proves problem is with pygame.image.frombytes()  (And then workaround was done.)
            new_size = (width, height)  # NOTE: This is the size of the already-resized image. No resizing occurs here.
            if cfg.PYGAME_FROMBYTES_IMAGE_LOAD_WORKAROUND_ENABLE:  # A BAD BUT VERY TEMPORARY HACK (which works great)
                # Obviously the following can have race conditions and is a very hackish hack and NOT a solution.
                filesystem_loaded_resized_surface_hack = pygame.image.load(
                    'load-image-temp-out-png.png'
                ).convert_alpha()
                surface_l = filesystem_loaded_resized_surface_hack  # For clarity
            else:
                alphonically_resized_surface = pygame.image.frombytes(
                        resized_png_bytes,
                        size=new_size,
                        format='RGBA',
                    ).convert_alpha()
                # ******************************************************************
                # PERSISTENT ERROR:
                #     fbtest = pygame.image.frombytes(img_bytes, size=(140, 140), format='RGBA').convert_alpha()
                #              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                # ValueError: Bytes length does not equal format and resolution size
                # ******************************************************************
                surface_l = alphonically_resized_surface
    else:
        surface_l: pygame.Surface = pygame.image.load(image_path).convert_alpha()

    if flip:
        surface_l = pygame.transform.flip(surface_l, True, False)

    # Create RIGHT-facing surface:
    surface_r: pygame.Surface = pygame.transform.flip(surface_l, True, False)

    # print(filename)
    # print(surface_l)
    # print(surface_r)
    # ADD CACHE ITEM:
    c_item: SurfCacheItem = {
            'surface_l': surface_l,
            'surface_r': surface_r,
        }
    SCACHE[filename] = c_item


def event_meatball(group_ref: pygame.sprite.Group):
    meatball_spec = ent.weapon_specs[1]
    spawn_x = random.randint((0 - cfg.MEATBALL_SPAWN_MARGIN), (cfg.SCREEN_WIDTH + cfg.MEATBALL_SPAWN_MARGIN))
    spawn_y = random.randint((0 - 2 * cfg.MEATBALL_SPAWN_MARGIN), ( 0 - cfg.MEATBALL_SPAWN_MARGIN))
    # print(f"Meatball spawning at : {spawn_x}, {spawn_y}")
    projectile: Weapon = Weapon(
            groups=[all_sprites, group_ref],
            img_filename=meatball_spec['img_filename'],
            x=spawn_x,
            y=spawn_y,
            direction=pygame.math.Vector2((0.0, 1.0)),  # Down (Meatballs fall from the sky.)
            speed=meatball_spec['s'],
        )  # PyCharm FALSE WARNING HERE (AbstractGroup)


# ###############################################    INITIALIZATION    #################################################

pygame.init()

# INITIALIZE THE MAIN DISPLAY SURFACE (SCREEN / WINDOW)
display_surface = pygame.display.set_mode((cfg.SCREEN_WIDTH, cfg.SCREEN_HEIGHT))
pygame.display.set_caption(cfg.GAME_TITLE)

# CREATE SPRITE GROUPS
all_sprites: pygame.sprite.Group = pygame.sprite.Group()
all_players: pygame.sprite.Group = pygame.sprite.Group()
all_weapons: pygame.sprite.Group = pygame.sprite.Group()
all_npcs: pygame.sprite.Group = pygame.sprite.Group()
all_props: pygame.sprite.Group = pygame.sprite.Group()
all_colliders: pygame.sprite.Group = pygame.sprite.Group()

# GENERATE PROP SPECS - 'SPRAY' REPLICATED PROPS (randomly within specified radius, to specified count)
generated_prop_specs = []
for prop_t in ent.prop_templates:
    for index in range(prop_t['spray_count']):  # We will use the index for a unique prop name. Not critical.
        generated_prop_spec: ent.PropSpec = {
                'name': prop_t['name'] + str(index),  # Unique name of (sprayed) generated_prop_spec. (Compared to npc_spec which are hardcoded.)
                'instance_id': -1,  # -1 means instance not instantiated yet.
                'img_filename': prop_t['img_filename'],  # Copy the unchanging attributes from the template before handling dynamic ones.
                'flip': False,
                'resize': False,
                'w': prop_t['w'],
                'h': prop_t['h'],
                'color': prop_t['color'],
                'x': 0.0,  # placeholder (mpypy)
                'y': 0.0,  # placeholder (mpypy)
                }

        diameter = 2.0 * prop_t['spray_radius']  # This variable makes it easier to read/understand. Inline for perf.
        generated_prop_spec['name'] = prop_t['name'] + "-" + str(index)
        x_offset = random.uniform(0.0, diameter) - prop_t['spray_radius']  # uniform() gives a random float value
        y_offset = random.uniform(0.0, diameter) - prop_t['spray_radius']  # uniform() includes the limits
        generated_prop_spec['x'] = prop_t['x'] + x_offset
        generated_prop_spec['y'] = prop_t['y'] + y_offset

        generated_prop_specs.append(generated_prop_spec)


# ################################################    INSTANTIATION    #################################################

# TODO: See if we can move the prop spec (spraying/generation) code inside of prop instantiation. Probably can/should.
# NOTE: When using load_image(): To keep image size original, specify None for width and height.


# NOTE: The dictionaries for each Entity subclass holding unique-name-keyed references to the instances was just put
# back in place. This had been there in the earliest version in the form of lists but were tentatively removed while
# sprite groups were implemented. This is one of many ways to access sprite or other instances and one can think of
# these as the "easy", "global" way to access instances. If one is originating things from just inside the classes
# through update() or some other method triggered through sprite groups, then some things can be more akward than
# necessary, possibly collision-handling for example. For collisions, it is possible that handling them from the
# global level (directly within the main loop and not triggered/handled from within Entity-sub-classed insstances)
# is easier and at the moment that is the approach I am taking to collisions. The golbal instance dictionaries were
# put (back) in place for this purpose, but I knew I would but them in place for multiple reasons. Some things are best
# done from within instances and some things are best done from the global/main-loop level, even if some of the
# code may also live inside instance or class methods. Things that involve sprite-interactions and custom interactions
# will tend to originate from the main loop. Things that are more between the sprite and itself, the environment, time
# etc. may tend to originate from within the class, triggered via sprite-groups. Each use-case or feature will
# determine which strategy to use or even a mixture of the two with additional facilities involved, no doubt.


# INSTANITATE PLAYER SPRITE(S)
players: dict[str, Player] = {}
for i, player_spec in enumerate(ent.player_specs):
    player_spec['name'] = player_spec['name'] + str(i)
    player_spec['instance_id'] = i
    load_image(
            filename=player_spec['img_filename'],
            flip=player_spec['flip'],
            resize=player_spec['resize'],
            width=player_spec['w'],
            height=player_spec['h'],
        )
    player: Player = Player(
            groups=[all_sprites, all_players, all_colliders],
            img_filename=player_spec['img_filename'],
            weapon_spec=ent.weapon_specs[cfg.PLAYER_MAIN_WEAPON_INDEX],  # TODO: Felt hackish initially. Keep like this?
            all_weapons_group_ref=all_weapons,  # TODO: Felt hackish initially. Keep like this?
            # TODO: Will starting passing a list of groups in .._ref because we will add all_colliders and maybe others.
            x=player_spec['x'],
            y=player_spec['y'],
            direction=player_spec['d'],
            speed=player_spec['s'],
        )  # PyCharm FALSE WARNING HERE (AbstractGroup)
    players[player_spec['name']] = player  # Key off name or instance id. name should be unique

# INSTANITATE NPC SPRITES
npcs: dict[str, Npc] = {}
for i, npc_spec in enumerate(ent.npc_specs):
    npc_spec['instance_id'] = i
    load_image(
            filename=npc_spec['img_filename'],
            flip=npc_spec['flip'],
            resize=npc_spec['resize'],
            width=npc_spec['w'],
            height=npc_spec['h'],
        )
    npc: Npc = Npc(
            groups=[all_sprites, all_npcs, all_colliders],
            img_filename=npc_spec['img_filename'],
            x=npc_spec['x'],
            y=npc_spec['y'],
            direction=npc_spec['d'],
            speed=npc_spec['s'],
        )  # PyCharm FALSE WARNING HERE (AbstractGroup)
    npcs[npc_spec['name']] = npc  # Key off name or instance id. name should be unique

# INSTANITATE PROP SPRITES
props: dict[str, Prop] = {}
for i, generated_prop_spec in enumerate(generated_prop_specs):
    generated_prop_spec['instance_id'] = i
    load_image(
            filename=generated_prop_spec['img_filename'],
            flip=generated_prop_spec['flip'],
            resize=generated_prop_spec['resize'],
            width=generated_prop_spec['w'],
            height=generated_prop_spec['h'],
        )
    prop: Prop = Prop(
            groups=[all_sprites, all_props],
            img_filename=generated_prop_spec['img_filename'],
            x=generated_prop_spec['x'],
            y=generated_prop_spec['y'],
        )  # PyCharm FALSE WARNING HERE (AbstractGroup)
    props[generated_prop_spec['name']] = prop  # Key off name or instance id. name should be unique


# LOAD SURFACE CACHE WITH WEAPON DATA. (No Weapons have been instantiated at this point.)
for i, weapon_spec in enumerate(ent.weapon_specs):
    weapon_spec['instance_id'] = i
    load_image(
            filename=weapon_spec['img_filename'],
            flip=weapon_spec['flip'],
            resize=weapon_spec['resize'],
            width=weapon_spec['w'],
            height=weapon_spec['h'],
        )


# ###############################################    MAIN EXECUTION    #################################################

if not __name__ == '__main__':
    print("PyGameFun main.py has been imported. Some initialization has been performed. "
        "Main execution will not be started. Normally this file is executed as the app entry point and not imported.")
    sys.exit(0)

bgpath = os.path.join(cfg.ASSET_PATH, cfg.BGIMG)

if cfg.DEBUG:
    bg_surface = pygame.Surface((cfg.SCREEN_WIDTH, cfg.SCREEN_HEIGHT))
    bg_surface.fill(cfg.BGCOLOR)
else:
    bg_surface = pygame.image.load(bgpath)

running = True
ephase = None
g_ephase_name = None

ephase_count = 0  # 0, not None since we will likly first/always do an arithmetic check on it, not an existence check.
clock = pygame.time.Clock()

# CUSTOM EVENTS - Random meatballs
meatball_event = pygame.event.custom_type()
pygame.time.set_timer(meatball_event, cfg.MEATBALL_SPAWN_TIME_MIN + cfg.MEATBALL_SPAWN_TIME_RANGE)
# TODO: Meatball spawn time with current timer is only set randomly once at game start. MAKE IT VARY ALL THE TIME.

all_weapons_group_ref=all_weapons  # Here for clarity. We need to pass this to anything that instantiates weapons.
all_sprites_group_ref=all_sprites  # Again, for clarity. TODO: There is a CHANGE I may need to pass this in IF I ever
#                                                              need to use it. Currently not used and not passed in.


#   * * * * * * * * * * * * * * * * * * * * * * * *
#   * * * * * * * *    MAIN LOOP    * * * * * * * *
#   * * * * * * * * * * * * * * * * * * * * * * * *
while running:
    g_delta_time = clock.tick(cfg.TICKRATE) / 1000  # Seconds elapsed for a single frame (e.g. - 60 Frm/sec = 0.017 sec/Frm)


    # ##################################################    INPUT    ###################################################

    for event in pygame.event.get():  # Check all new events since the last main loop iteration
        if event.type == pygame.QUIT:
            running = False
        if event.type == meatball_event:
            event_meatball(all_weapons_group_ref)


    # #######################################    ENVIRONMENT PHASE PROCESSING    #######################################

    # ENVIRO_PHASES is a collections.deque instance and we popleft() the first/current 'phase'.
    #     Then we add the phase we removed from the left/start of the (deque) to the end (right side/last position).
    if ephase is None:
        ephase = cfg.ENVIRO_PHASES[0]
        g_ephase_name = ephase[0]
        ephase_count = ephase[1]
        cut_ephase = cfg.ENVIRO_PHASES.popleft()
        cfg.ENVIRO_PHASES.append(cut_ephase)
    else:
        ephase_count -= 1  # Decrement the counter for the current phase.
        if ephase_count < 1:
            ephase = None


    # #################################################    UPDATE    ###################################################

    all_props.update(g_delta_time, g_ephase_name)
    all_npcs.update(g_delta_time, g_ephase_name)
    all_players.update(g_delta_time, g_ephase_name)
    all_weapons.update(g_delta_time, g_ephase_name)  # Must update Weapons AFTER Player since Player creates Weapons during Player update.


    # ###############################################    COLLISIONS    #################################################

    if players['buck0'].rect.collidepoint(pygame.mouse.get_pos()):  # Soon will likely use sprite collisions, not rect.
        print("BOINGGGGGGG!!")

    player_cols = None
    pygame.sprite.spritecollide(players['buck0'], all_colliders, False, collided=player_cols)

    if player_cols:
        print(player_cols)

    # ##################################################    DRAW    ####################################################

    # REDRAW THE BACKGROUND
    if cfg.ACID_MODE is False:
        display_surface.blit(bg_surface, (0, 0))

    all_props.draw(display_surface)
    all_npcs.draw(display_surface)
    all_weapons.draw(display_surface)
    all_players.draw(display_surface)

    pygame.display.flip()  # Similar to update but not entire screen. TODO: Clarify
    # TODO: The tutorial has now gone back to using .update() at some point. Again, need to clarify and -> use best one.


#   - * - * - * - * - * - * - * - * - * - * - * - * -
#   - * - * - * -     END MAIN LOOP     - * - * - * -
#   - * - * - * - * - * - * - * - * - * - * - * - * -


pygame.quit()


##
#


# ###################################################    NOTES    ######################################################

# PYGAME-CE DOCS:
# https://pyga.me/docs/


##
#
