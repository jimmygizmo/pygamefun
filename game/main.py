#! /usr/bin/env -vS python

import config as cfg
import entity as ent
import sys
import os.path
from typing import TypedDict
import pygame
import random
import resizer


# ###########################################    GLOBAL INITIALIZATION    ##############################################


# TODO: Document how filename and frames_dir will be unique (both are relative paths under /assets/ and files/dirs)
#     in the same dir must have unique names. THUS, these are used as the keys to the hash entries for the resources
#     stored in the cache for these unique paths. One is an image filename and the other is a directory name, which
#     will be full of sequentially-named image files. In both cases these are unique identifiers, enforced by the fact
#     that these are paths within the same base path in the filesystem. This is a nice clean and simple mechanism
#     to use for unique keys for the cache which also have excellent semantics.
# SURFACE CACHE - 'SCACHE'
# The Surface Cache SCACHE pre-loads images into surfaces. When sprites are instantiated, they will use this cache
# for surfaces and not need to load them from disk. This is important for dynamically/frequently spawned/destroyed sprites.
SurfCacheItem = TypedDict('SurfCacheItem',
    {
        'surface_l': pygame.Surface,  # Image as loaded and with 'flip' options and/or 'resize' options applied if True. Should be LEFT facing.
        'surface_r': pygame.Surface,  # Flipped (assumed to be RIGHT-facing) version of image. Generated by load_image()
        'mask_l': pygame.Mask,  # Mask from surface LEFT
        'mask_r': pygame.Mask,  # Mask from surface RIGHT
        'mask_surf_l': pygame.Surface,  # Mask Surface LEFT - TODO: These may be used later for special effects.
        'mask_surf_r': pygame.Surface,  # Mask Surface RIGHT - TODO: "
    }
)  # SurfCacheitem
SCACHE: dict[str, SurfCacheItem] = {}  # The Surface Cache. Key = filename, Value = SurfCacheItem.

# TODO: Description.
AnimCacheItem = TypedDict('AnimCacheItem',
    {
        'frames': list[pygame.Surface],
    }
)  # AnimCacheItem
ACACHE: dict[str, AnimCacheItem] = {}  # The Animation Cache. Key = frames_dir, Value = AnimCacheItem.

# TODO: I don't know that we need any masks for the animations/frames at this point, or ever would. It's not impossible.


# #############################################    CLASS DEFINITIONS    ################################################

class Anim(pygame.sprite.Sprite):
    base_instance_count: int = 0
    def __init__(self,
                groups: list[pygame.sprite.Group],
                frames_dir: str,
                x: float,
                y: float,
                frame_rate: float,
            ):
        self.base_instance_id: int = MapThing.base_instance_count
        self.frames: list[pygame.Surface] = ACACHE[frames_dir]['frames']
        self.x: float = x
        self.y: float = y
        self.image: pygame.Surface | None = None  # Active image
        self.rect: pygame.FRect = pygame.FRect()
        super().__init__(groups)  # super.update() could be done first before setting all the self.* but for now I have them last.
        Anim.base_instance_count += 1
        self.rect = self.image.get_frect(center=(self.x, self.y))










# TODO: Make into an Abstract Base Class using the ABC module.
# TODO: Add support for Angle (self.angle) and for Props it can just be set when instantiated. Props don't update or move.
#     Random angles for 'sprayed' props would be a nice feature. Random angular_vel would be nice for NPCs, Weapons perhaps.
class MapThing(pygame.sprite.Sprite):
    base_instance_count: int = 0
    def __init__(self,
                groups: list[pygame.sprite.Group],
                img_filename: str,
                x: float,
                y: float,
                angle: float,
            ):
        self.base_instance_id: int = MapThing.base_instance_count
        self.surface_l: pygame.Surface = SCACHE[img_filename]['surface_l']
        self.surface_r: pygame.Surface = SCACHE[img_filename]['surface_r']
        self.mask_l: pygame.Mask = SCACHE[img_filename]['mask_l']
        self.mask_r: pygame.Mask = SCACHE[img_filename]['mask_r']
        self.mask_surf_l: pygame.Surface = SCACHE[img_filename]['mask_surf_l']  # TODO: These may be used later for special effects.
        self.mask_surf_r: pygame.Surface = SCACHE[img_filename]['mask_surf_r']  # TODO: "
        self.x: float = x
        self.y: float = y
        self.angle: float = angle
        self.image: pygame.Surface | None = None  # Active image (depending on direction of motion).
        self.mask: pygame.Mask | None = None  # Active mask (depending on direction of motion).
        self.rect: pygame.FRect = pygame.FRect()
        super().__init__(groups)  # super.update() could be done first before setting all the self.* but for now I have them last.
        MapThing.base_instance_count += 1
        self.rect = self.surface_l.get_frect(center=(self.x, self.y))

        if cfg.WHITEOUT_MODE:
            self.mask_surf_l.set_colorkey((0, 0, 0))  # Make the black transparent.
            self.mask_surf_r.set_colorkey((0, 0, 0))  # "
            self.surface_l = self.mask_surf_l  # White-out the object.
            self.surface_r = self.mask_surf_r  # "

        # Props only use the LEFT side image and mask for everything, at this time.
        self.image = self.surface_l
        self.mask = self.mask_l

    # NOTICE: MapThing has no update(), no physics_outer_walls() like Entity has.


# TODO: Make into an Abstract Base Class using the ABC module.
class Entity(pygame.sprite.Sprite):
    base_instance_count: int = 0
    def __init__(self,
                groups: list[pygame.sprite.Group],
                img_filename: str,
                x: float,
                y: float,
                direction: pygame.math.Vector2,
                speed: float,
                angle: float,
                angular_vel: float,
                e_spec: ent.EnviroSpec | None = None,  # =None makes it optional. Prop has no e_spec. All others do.
            ):
        self.base_instance_id: int = Entity.base_instance_count
        self.surface_l: pygame.Surface = SCACHE[img_filename]['surface_l']
        self.surface_r: pygame.Surface = SCACHE[img_filename]['surface_r']
        self.mask_l: pygame.Mask = SCACHE[img_filename]['mask_l']
        self.mask_r: pygame.Mask = SCACHE[img_filename]['mask_r']
        self.mask_surf_l: pygame.Surface = SCACHE[img_filename]['mask_surf_l']  # TODO: These may be used later for special effects.
        self.mask_surf_r: pygame.Surface = SCACHE[img_filename]['mask_surf_r']  # TODO: "
        self.x: float = x
        self.y: float = y
        self.dir: pygame.math.Vector2 = direction
        self.speed: float = speed
        self.angle: float = angle
        self.angular_vel: float = angular_vel
        self.e_spec = e_spec
        self.image: pygame.Surface | None = None  # Active image (depending on direction of motion).
        self.mask: pygame.Mask | None = None  # Active mask (depending on direction of motion).
        self.rect: pygame.FRect = pygame.FRect()
        super().__init__(groups)  # super.update() could be done first before setting all the self.* but for now I have them last.
        Entity.base_instance_count += 1
        self.rect = self.surface_l.get_frect(center=(self.x, self.y))  # TODO: LIKELY EXCESSIVE INIT WE CAN MAKE NONE
        # TODO: We can do this if we confirm that update() will ALWAYS be called first, even in edge cases.
        # Also the canonically-correct thing to do is to get this rect from self.image, but at this point in may simply
        # be premature to do certain init activities. If that is the conclusion, then we need more of the Type | None = None
        # True, we are in the process of replacing more init to the more lightweight Type | None = None. It's a case by case
        # basis but this one also looks like it will be able to be None here. Just check when update() first gets called,
        # like when the game first starts etc. Or for weapons newly instantiated etc.

        if cfg.WHITEOUT_MODE:
            self.mask_surf_l.set_colorkey((0, 0, 0))  # Make the black transparent.
            self.mask_surf_r.set_colorkey((0, 0, 0))  # "
            self.surface_l = self.mask_surf_l  # White-out the object.
            self.surface_r = self.mask_surf_r  # "

    def update(self, delta_time: float, ephase_name: str | None = None):
        delta_vector: pygame.math.Vector2 = self.dir * self.speed * delta_time
        # MYPY ERROR HERE - TRICKY ONE:
        # main.py:365: error: Incompatible types in assignment (expression has type "Vector2",
        #     variable has type "tuple[float, float]")  [assignment]
        self.rect.center += delta_vector
        # ***************************

        self.physics_outer_walls()  # Handle bouncing off walls. NOTE: Props override this and pass. Props ignore walls.
        # In fact, inside Props we override and pass update() too, so calling of physics_outer_walls() will never occur
        # here for props. To clarify, inside Prop, BOTH update() and physics_outer_walls() are overridden and passed.

        # Activate the correctly-facing image and mask, based on X direction. Use expensive rotation, if enabled.
        if cfg.ROTATION:
            # TODO: FIX DELTA_TIME ISSUE. I cannot scale rotation like this with current delta_time being so small. When you
            #     enable this and do it like linear velocity, it just looks like rotation stops. I think I hit this issue earlier
            #     with speed and then just increased my speeds artificially. The problem has to do with the units I am using
            #     vs. the frame rate. I should problably set a baseline based on ROTATION through 360 and then figure things
            #     backwards to determine my ARBITRARY speed/linear-vel values and thus end up with something I can use the same
            #     delta_time value. Degress with there being 360 cannot be scaled like an arbitrary linear velocity/distance can.
            #     I suppose we could use a separate/modified delta_time to use for rotation, but the first plan is the best by far.
            # self.angle += self.angular_vel * delta_time  # ROTATE BY THE ANGULAR VELOCITY    *** CURRENTLY JUST MAKES ROTATION WAY WAY TOO SLOW ***
            self.angle += self.angular_vel  # ROTATE BY THE ANGULAR VELOCITY
            # TODO: Make this reset to 360 degrees PLUS the amount it just PASSED 260 degrees. No jerking. Best general behavior.
            #     Think about this though for full context. When the rotation transform method is called and if it is given
            #     a parameter > 360 degrees, one might safely assume that it is going to do the exact same thing. In fact,
            #     the math libraries inevitably used by the rotation method in PyGame will likely do that. It will be
            #     an automatic result. STILL, I fill like adding my own code here for that. This can be considered more
            #     On a performance note, it might be MOST efficient to pass the angle unchanged, even if it is > 360.
            #     This is because the code that checks or resolbes the issue downstream is going to most likely run (or take effect via math) anyhow.
            #     So earlier additional checks to convert to < 360 would then be totally unnecessary and wasted cycles.
            #     When you are optimizing for performance and other resources, you have to think about it carefully ..
            #     and then ultimately you need to do performance profiling (running code a measuring time spent in
            #     specific code lines/routines).
            if self.angle >= 360:
                self.angle = 0.0
            if self.dir.x < 0:  # MOVING LEFT - ROTATION ENABLED
                self.image = pygame.transform.rotozoom(self.surface_l, self.angle, 1.0)
                self.mask = self.mask_l  # TODO: FIX THIS. WRONG MASK. NEEDS ROTATE.
            else:  # MOVING RIGHT - ROTATION ENABLED
                self.image = pygame.transform.rotozoom(self.surface_r, self.angle, 1.0)
                self.mask = self.mask_r  # TODO: FIX THIS. WRONG MASK. NEEDS ROTATE.
        else:  # No rotation:
            if self.dir.x < 0:  # MOVING LEFT
                self.image = self.surface_l
                self.mask = self.mask_l
            else:  # MOVING RIGHT
                self.image = self.surface_r
                self.mask = self.mask_r

        self.rect = self.image.get_frect(center=self.rect.center)

    def physics_outer_walls(self):
        # Bounce off LEFT wall in X Axis
        if self.rect.left <= 0:
            self.rect.left = 0
            self.dir.x *= -1

        # Bounce off RIGHT wall in X Axis
        if self.rect.right >= cfg.SCREEN_WIDTH:
            self.rect.right = cfg.SCREEN_WIDTH
            self.dir.x *= -1

        # Bounce off TOP wall in Y Axis
        if self.rect.top <= 0:
            self.rect.top = 0
            self.dir.y *= -1

        # Bounce off BOTTOM wall in Y Axis
        if self.rect.bottom >= cfg.SCREEN_HEIGHT:
            self.rect.bottom = cfg.SCREEN_HEIGHT
            self.dir.y *= -1


class Player(Entity):
    instance_count: int = 0
    def __init__(self,
                groups: list[pygame.sprite.Group],
                img_filename: str,
                weapon_spec: ent.WeaponSpec,
                weapon_e_spec: ent.EnviroSpec,
                weapons_groups: list[pygame.sprite.Group],
                x: float,
                y: float,
                direction: pygame.math.Vector2,
                speed: float,
                angle: float,
                angular_vel: float,
                e_spec: ent.EnviroSpec | None = None,  # =None makes it optional. Don't pass e_spec and you get no enviro-behavior.
            ):
        self.instance_id: int = Player.instance_count
        self.weapon_spec = weapon_spec
        self.weapon_e_spec = weapon_e_spec
        self.weapons_groups = weapons_groups
        self.can_shoot: bool = True
        self.laser_shoot_time: int = 0
        self.cooldown_duration: int = cfg.LASER_COOLDOWN_DURATION  # milliseconds
        super().__init__(
            groups=groups,
            img_filename=img_filename,
            x=x,
            y=x,
            direction=direction,
            speed=speed,
            angle=angle,
            angular_vel=angular_vel,
            e_spec=e_spec)  # super.update() could be done first before setting all the self.* but for now I have them last.
        Player.instance_count += 1

    def laser_timer(self):
        if not self.can_shoot:
            current_time = pygame.time.get_ticks()  # Milliseconds since pygame.init() was called.
            if current_time - self.laser_shoot_time >= self.cooldown_duration:
                self.can_shoot = True

    def update(self, delta_time: float, ephase_name: str | None = None):
        enviro_influence(self, ephase_name)

        keys = pygame.key.get_pressed()
        recent_keys = pygame.key.get_just_pressed()

        self.dir.x = int(keys[pygame.K_RIGHT]) - int(keys[pygame.K_LEFT])
        self.dir.y = int(keys[pygame.K_DOWN]) - int(keys[pygame.K_UP])

        self.dir = self.dir.normalize() if self.dir else self.dir

        if recent_keys[pygame.K_SPACE] and self.can_shoot:
            self.can_shoot = False
            self.laser_shoot_time = pygame.time.get_ticks()
            weapon_img_filename = self.weapon_spec['img_filename']
            projectile: Weapon = Weapon(
                    groups=self.weapons_groups,
                    img_filename=weapon_img_filename,
                    x=self.rect.midtop[0],
                    y=self.rect.midtop[1],
                    direction=self.weapon_spec['d'],
                    speed=self.weapon_spec['s'],
                    angle=self.weapon_spec['a'],
                    angular_vel=self.weapon_spec['av'],
                    e_spec=self.weapon_e_spec,
                )
        self.laser_timer()
        # NOTE: WE UPDATE BASED ON INPUT --BEFORE-- WE CHECK FOR WALL COLLISION/BOUNCING (in super/Entity).
        super().update(delta_time, ephase_name)


class Weapon(Entity):
    instance_count: int = 0
    def __init__(self,
                groups: list[pygame.sprite.Group],
                img_filename: str,
                x: float,
                y: float,
                direction: pygame.math.Vector2,
                speed: float,
                angle: float,
                angular_vel: float,
                e_spec: ent.EnviroSpec | None = None,  # =None makes it optional. Don't pass e_spec and you get no enviro-behavior.
            ):
        self.instance_id: int = Weapon.instance_count
        super().__init__(
            groups=groups,
            img_filename=img_filename,
            x=x,
            y=y,
            direction=direction,
            speed=speed,
            angle=angle,
            angular_vel=angular_vel,
            e_spec=e_spec)  # super.update() could be done first before setting all the self.* but for now I have them last.
        Weapon.instance_count += 1

    def update(self, delta_time: float, ephase_name: str | None = None):
        enviro_influence(self, ephase_name)
        super().update(delta_time, ephase_name)

    def physics_outer_walls(self):  # Overrides Entity.physics_outer_walls().
        # Projectiles/weapons are deleted beyond some margin and do not bounce off the outer walls.
        if self.rect.left <= 0 - cfg.PROJECTILE_MARGIN:  # A little beyond LEFT wall in X Axis
            self.kill()
        if self.rect.right >= cfg.SCREEN_WIDTH + cfg.PROJECTILE_MARGIN:  # A little beyond RIGHT wall in X Axis
            self.kill()
        if self.rect.top <= 0 - cfg.PROJECTILE_MARGIN:  # A little beyond TOP wall in Y Axis
            self.kill()
        if self.rect.bottom >= cfg.SCREEN_HEIGHT + cfg.PROJECTILE_MARGIN:  # A little beyond BOTTOM wall in Y Axis
            self.kill()


class Npc(Entity):
    instance_count: int = 0
    def __init__(self,
                groups: list[pygame.sprite.Group],
                img_filename: str,
                x: float,
                y: float,
                direction: pygame.math.Vector2,
                speed: float,
                angle: float,
                angular_vel: float,
                e_spec: ent.EnviroSpec | None = None,  # =None makes it optional. Don't pass e_spec and you get no enviro-behavior.
            ):
        self.instance_id: int = Npc.instance_count
        super().__init__(
            groups=groups,
            img_filename=img_filename,
            x=x,
            y=y,
            direction=direction,
            speed=speed,
            angle=angle,
            angular_vel=angular_vel,
            e_spec=e_spec)  # super.update() could be done first before setting all the self.* but for now I have them last.

        Npc.instance_count += 1

    def update(self, delta_time: float, ephase_name: str | None = None):
        enviro_influence(self, ephase_name)
        super().update(delta_time, ephase_name)


class Prop(MapThing):
    instance_count: int = 0
    def __init__(self,
                groups: list[pygame.sprite.Group],
                img_filename: str,
                x: float,
                y: float,
                angle: float,
            ):
        self.instance_id: int = Prop.instance_count
        super().__init__(groups, img_filename, x, y, angle)  # super.update() can be done before or after setting any self.* but think about how it might matter! Maybe not at all.
        Prop.instance_count += 1


# #############################################    FUNCTION DEFINITIONS    #############################################

def enviro_influence(xself: Player | Weapon | Npc, ephase_name: str) -> None:
    if ephase_name == 'peace':
        xself.speed = xself.e_spec['e_p']
    elif ephase_name == 'rogue':
        xself.speed = xself.e_spec['e_r']
    elif ephase_name == 'chaos':
        xself.speed = xself.e_spec['e_c']
    elif ephase_name == 'frozen':
        xself.speed = xself.e_spec['e_f']
    else:
        raise ValueError(f"FATAL: Invalid ephase_name '{ephase_name}'. "
                         "Check values in ENVIRO_PHASES config.")


def load_image(
            filename: str,
            flip: bool,
            resize: bool,
            width: int | None,
            height: int | None,
        ) -> None:
    image_path = os.path.join(cfg.ASSET_PATH, filename)
    surface_l: pygame.Surface = pygame.Surface((0, 0))  # TODO: Make thiS TYPE | None = None (after analysis)
    if resize:
        if width and height:
            with open(image_path, 'rb') as fh:
                img_bytes = fh.read()
            resized_png_bytes = resizer.alphonic_resize(
                    img_data=img_bytes,
                    width=width,
                    height=height,
                )
            # Output of this file was originally for validation, and now it is a workaround until frombytes() works.
            with open('load-image-temp-out-png.png', 'wb') as fh:
                fh.write(resized_png_bytes)
            # This image data is good! Proves problem is with pygame.image.frombytes()  (And then workaround was done.)
            new_size = (width, height)  # NOTE: This is the size of the already-resized image. No resizing occurs here.
            if cfg.PYGAME_FROMBYTES_IMAGE_LOAD_WORKAROUND_ENABLE:  # A BAD BUT VERY TEMPORARY HACK (which works great)
                # Obviously the following can have race conditions and is a very hackish hack and NOT a solution.
                filesystem_loaded_resized_surface_hack = pygame.image.load(
                    'load-image-temp-out-png.png'
                ).convert_alpha()
                surface_l = filesystem_loaded_resized_surface_hack  # For clarity
            else:
                alphonically_resized_surface = pygame.image.frombytes(
                        resized_png_bytes,
                        size=new_size,
                        format='RGBA',
                    ).convert_alpha()
                # ******************************************************************
                # PERSISTENT ERROR:
                #     fbtest = pygame.image.frombytes(img_bytes, size=(140, 140), format='RGBA').convert_alpha()
                #              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                # ValueError: Bytes length does not equal format and resolution size
                # ******************************************************************
                surface_l = alphonically_resized_surface
    else:
        surface_l = pygame.image.load(image_path).convert_alpha()

    if flip:
        surface_l = pygame.transform.flip(surface_l, True, False)

    mask_l: pygame.Mask = pygame.mask.from_surface(surface_l)  # Mask from surface LEFT. Done after possible flip and regardless of resize or not.
    mask_surf_l: pygame.Surface = mask_l.to_surface()  # Now a 'mask surface' from that (black & white silhouette)  # TODO: NOT USING THIS YET. Remove?

    # Create RIGHT-facing surface and mask:
    surface_r: pygame.Surface = pygame.transform.flip(surface_l, True, False)
    mask_r: pygame.Mask = pygame.mask.from_surface(surface_r)  # Mask from surface RIGHT
    # And Mask Surface RIGHT:
    mask_surf_r: pygame.Surface = mask_r.to_surface()  # Now a 'mask surface' from that (black & white silhouette)

    # TODO: Mask Surfaces (not Masks) mask_surf_l and mask_surf_r MAY be used later for special effects.

    sc_item: SurfCacheItem = {
            'surface_l': surface_l,
            'surface_r': surface_r,
            'mask_l': mask_l,
            'mask_r': mask_r,
            'mask_surf_l': mask_surf_l,
            'mask_surf_r': mask_surf_r,
        }
    SCACHE[filename] = sc_item


def load_anim_frames(
            frames_dir: str,
            flip: bool,
            resize: bool,
            width: int | None,
            height: int | None,
        ) -> None:
    frames_path = os.path.join(cfg.ASSET_PATH, frames_dir)
    frames: list[pygame.Surface] = []
    file_path_sequence = sorted(os.listdir(frames_path))
    for filename in file_path_sequence:
        if filename.endswith('.png'):
            image_path = os.path.join(frames_path, filename)
            print(image_path)  #  ***  DEBUG  ***
            frame_surface = pygame.image.load(image_path).convert_alpha()  # For clarity.  TODO: Inline to optimize.
            frames.append(frame_surface)

    ac_item: AnimCacheItem = {
            'frames': frames,
        }
    ACACHE[frames_dir] = ac_item


# UPDATE: Below is already fixed just above here but this issue needs consistent resolution throught this project.
# TODO: *** CRITICAL ***  OK, We cannot do TYPE | None = None INITS in some new places I just discovered or re-discovered.
#    At least with respect to PyGame warnings and possibly also MyPy (not confirmed yet) I am getting a waring about the | None.
#    This is the error, about the value/variable I am passing to frames attribute in AnimCacheItem above:
#    ERROR: Expected type 'list[Surface]', got 'list[Surface] | None' instead
#    *** This changes things. I thought I could be more efficient in MANY places by adding the | None and thus removing some
#        more heavyweight INIT like creating a surface etc. But I guess I cannot and still keep PyCharm and MyPy warnings happy.
#        Am I looking at a strong reason to now selectively suppress some warnings? I hate seeing them, but I still would
#        like to stay ahead of performance optimization and not create objects simply to satisfy static code inspection.
#        I don't see a case where the | None creates more risk for bugs. On the contrary, it is so PYTHONIC, I see the | None for
#        many INIT cases, to be almost essential. I'll need to look into suppressing both PyCharm and MyPy warnings as an option.
#        On larger projects you inevitably do suppress many warnings as there will be a large amount of analysis in the
#        CI/CD pipeline and lots of interest by management in active usage and tuning of static code analysis and other reports.
#        The performance reports can be used to counter-balance adherance to static-code analysis and enforcement related to that.
#        In the case of the stuff I am talking about here, I am forced to use extra memory and CPU, simply to keep the warnings
#        down and that will not always be acceptable. Right now in this app it is not a problem, BUT my goal is to keep things
#        rather lean and optimized right from the beginning. Some users have slower machines. We need to remember that as well.


def event_meatball(groups: list[pygame.sprite.Group], e_spec_meatball: ent.EnviroSpec):
    meatball_spec = ent.weapon_specs[1]
    spawn_x = random.randint((0 - cfg.MEATBALL_SPAWN_MARGIN), (cfg.SCREEN_WIDTH + cfg.MEATBALL_SPAWN_MARGIN))
    spawn_y = random.randint((0 - 2 * cfg.MEATBALL_SPAWN_MARGIN), ( 0 - cfg.MEATBALL_SPAWN_MARGIN))
    random_av: float = 1.111  # Specific, to be replaced but assists any potential troubleshooting like this.
    if  7700.0 < meatball_spec['av'] < 7799.9:
        random_av = random_angular_vel(meatball_spec['av'])
    projectile: Weapon = Weapon(
            groups=groups,
            img_filename=meatball_spec['img_filename'],
            x=spawn_x,
            y=spawn_y,
            direction=pygame.math.Vector2((0.0, 1.0)),  # Meatballs fall straight down.
            speed=meatball_spec['s'],
            angle=meatball_spec['a'],
            angular_vel=random_av,
            e_spec=e_spec_meatball,
        )


def update_and_draw_scoreboard(
            arg_display_surface: pygame.Surface,
            arg_scoreboard_font: pygame.font.Font,
            score: int,
        ) -> None:
    # -------- SCOREBOARD TEXT
    score_text = str(score)
    scoreboard_surf: pygame.Surface = arg_scoreboard_font.render(
            text=score_text,
            antialias=True,
            color=cfg.SCR_FONT_COLOR,
            bgcolor=None,  # TODO: Should this arg just be left off?
        )
    scoreboard_rect: pygame.FRect = scoreboard_surf.get_frect(center=(cfg.SCR_X, cfg.SCR_Y))
    arg_display_surface.blit(scoreboard_surf, scoreboard_rect)

    # -------- SCORBOARD BORDER
    pygame.draw.rect(
            arg_display_surface,
            cfg.SCR_BORDER_COLOR,
            scoreboard_rect.inflate(cfg.SCR_BORDER_PAD_X, cfg.SCR_BORDER_PAD_Y)
                .move(0, cfg.SCR_FONT_ADJUST_Y),
            width=cfg.SCR_BORDER_THICKNESS,
            border_radius=cfg.SCR_BORDER_RADIUS,
        )


def composed_enviro_spec(spec_in: ent.PlayerSpec | ent.WeaponSpec | ent.NpcSpec) -> ent.EnviroSpec:
    spec_out: ent.EnviroSpec = {  # Do we really need these bloated inits to keep PyCharm and MyPy type-hinting checks fully happy? NO.
            'e_p': -9999.9,  # Enviro: Peace (speed)
            'e_r': -9999.9,  # Enviro: Rogue (speed)
            'e_c': -9999.9,  # Enviro: Chaos (speed)
            'e_f': -9999.9,  # Enviro: Frozen (speed)
        }
    key: ent.EnviroKeys  # Must declare the type before the loop as we cannot do this in the for statement itself.
    for key in spec_in.keys():
        if key.startswith('e_'):
            spec_out[key] = spec_in[key]
    return spec_out


def template_generated_prop_specs():
    gen_prop_specs = []
    for prop_t in ent.prop_templates:
        for index in range(prop_t['spray_count']):  # We will use the index for a unique prop name. Not critical.
            gen_prop_spec: ent.PropSpec = {
                'name': prop_t['name'] + str(index),
                # Unique name of (sprayed) gen_prop_spec. (Compared to npc_spec which are hardcoded.)
                'instance_id': -1,  # -1 means instance not instantiated yet.
                'img_filename': prop_t['img_filename'],
                # Copy the unchanging attributes from the template before handling dynamic ones.
                'flip': False,
                'resize': False,
                'w': prop_t['w'],
                'h': prop_t['h'],
                'color': prop_t['color'],
                'x': 0.0,  # placeholder (mpypy)
                'y': 0.0,  # placeholder (mpypy)
                'a': prop_t['a'],
            }

            diameter = 2.0 * prop_t['spray_radius']  # Makes it easier to read/understand. Inline this for performance.
            gen_prop_spec['name'] = prop_t['name'] + "-" + str(index)
            x_offset = random.uniform(0.0, diameter) - prop_t['spray_radius']  # uniform() gives a random float value
            y_offset = random.uniform(0.0, diameter) - prop_t['spray_radius']  # uniform() includes the limits
            gen_prop_spec['x'] = prop_t['x'] + x_offset
            gen_prop_spec['y'] = prop_t['y'] + y_offset

            gen_prop_specs.append(gen_prop_spec)
    return gen_prop_specs


# Takes av values and looks for special values for SLOW, MED. FAST or FULL-RANGE random rotation speed (angular velocity).
# 7701 - SLOW, 7702 - MED, 7703 - FAST, 7704 - FULL RANGE. The values involved will be changing as how delta_time is
# used will be changing. Returns a random angular velocity.
# We don't need a ROT_SLOW_MIN for now. But we use ROT_MAX as a sort of defualt SUPER FAST, so we have that one.
#     So if you go for FULL-RANGE 7704, or just let the default apply, then you get the SUPER FAST option.
def random_angular_vel(av_special_value: float) -> float:
    av: float = 1.222  # Specific only for troubleshooting. This is a default value to be replaced in all valid cases.
    if av_special_value == 7701.0:
        av =  random.uniform(cfg.ROT_MIN, (cfg.ROT_SLOW_MAX - cfg.ROT_MIN))
    elif av_special_value == 7702.0:
        av =  random.uniform(cfg.ROT_MED_MIN, (cfg.ROT_MED_MAX - cfg.ROT_MED_MIN))
    elif av_special_value == 7703.0:
        av =  random.uniform(cfg.ROT_FAST_MIN, (cfg.ROT_MAX - cfg.ROT_MED_MIN))
    else:
        av =  random.uniform(cfg.ROT_MIN, (cfg.ROT_MAX - cfg.ROT_MIN))
    if bool(random.getrandbits(1)):  # Rotation direction is simply random. TODO: Later it may be configurable via additional special values.
        av = av * -1.0
    return av


# ###############################################    INITIALIZATION    #################################################

pygame.init()

# INIT SCOREBOARD
if cfg.SCR_FONT_FORCE_SYSTEM:
    scoreboard_font = pygame.font.SysFont(cfg.SCR_SYSTEM_FONT, cfg.SCR_FONT_SIZE)
else:
    scoreboard_font = pygame.font.Font(os.path.join(cfg.ASSET_PATH, cfg.SCR_FONT_FILENAME), cfg.SCR_FONT_SIZE)


# INITIALIZE THE MAIN DISPLAY SURFACE (SCREEN / WINDOW)
display_surface = pygame.display.set_mode((cfg.SCREEN_WIDTH, cfg.SCREEN_HEIGHT))
pygame.display.set_caption(cfg.GAME_TITLE)

# CREATE SPRITE GROUPS
all_sprites: pygame.sprite.Group = pygame.sprite.Group()
all_players: pygame.sprite.Group = pygame.sprite.Group()
all_weapons: pygame.sprite.Group = pygame.sprite.Group()  # TODO: Might go away. Need more specific groups.
all_meatballs: pygame.sprite.Group = pygame.sprite.Group()
all_greenballs: pygame.sprite.Group = pygame.sprite.Group()
all_npcs: pygame.sprite.Group = pygame.sprite.Group()
all_props: pygame.sprite.Group = pygame.sprite.Group()
all_colliders: pygame.sprite.Group = pygame.sprite.Group()  # TODO: Might go away. We'll likely always be more specific.

# GROUPS FOR DYNAMIC ENTITIES
new_greenballs_groups: list[pygame.sprite.Group] = [all_sprites, all_greenballs, all_colliders]
new_meatballs_groups: list[pygame.sprite.Group] = [all_sprites, all_meatballs, all_colliders]
# TODO: JUST NOTING HERE AGAIN AS IN OTHER PLACES. WE REALLY DON'T NEED all_sprites. And probably neither all_colliders

generated_prop_specs = template_generated_prop_specs()


# ################################################    INSTANTIATION    #################################################

# Experimantal naming convention for variables at the global level which may have shadowing issues becuase their name
# is one likely to also be used in inner scopes. This is a system of a few prefixes to use on variable names, with
# a rough meaning:
# gr_    Lives in global scope and is intended for READ ONLY. Some bugs are still possible.
# gw_    Lives in global scope and may be written to. Many kinds of bugs possible if care is not taken.

# INSTANITATE PLAYER SPRITE(S)
players: dict[str, Player] = {}
for i, gr_player_spec in enumerate(ent.player_specs):
    gr_player_spec['name'] = gr_player_spec['name'] + str(i)
    gr_player_spec['instance_id'] = i
    load_image(
            filename=gr_player_spec['img_filename'],
            flip=gr_player_spec['flip'],
            resize=gr_player_spec['resize'],
            width=gr_player_spec['w'],
            height=gr_player_spec['h'],
        )
    gr_e_spec = composed_enviro_spec(gr_player_spec)
    gr_weapon_spec = ent.weapon_specs[cfg.PLAYER_MAIN_WEAPON_INDEX]
    gr_weapon_e_spec = composed_enviro_spec(gr_weapon_spec)  # TODO: This call COULD be done inside Player. Then we would not pass it to Player().
    player: Player = Player(
            groups=[all_sprites, all_players],
            img_filename=gr_player_spec['img_filename'],
            weapon_spec=gr_weapon_spec,
            weapon_e_spec=gr_weapon_e_spec,
            weapons_groups=new_greenballs_groups,
            x=gr_player_spec['x'],
            y=gr_player_spec['y'],
            direction=gr_player_spec['d'],
            speed=gr_player_spec['s'],
            angle=gr_player_spec['a'],
            angular_vel=gr_player_spec['av'],
            e_spec=gr_e_spec,
        )
    players[gr_player_spec['name']] = player  # Key off name or instance id. name should be unique

# INSTANITATE NPC SPRITES
npcs: dict[str, Npc] = {}
for i, gr_npc_spec in enumerate(ent.npc_specs):
    gr_npc_spec['instance_id'] = i
    load_image(
            filename=gr_npc_spec['img_filename'],
            flip=gr_npc_spec['flip'],
            resize=gr_npc_spec['resize'],
            width=gr_npc_spec['w'],
            height=gr_npc_spec['h'],
        )
    gr_e_spec = composed_enviro_spec(gr_npc_spec)
    npc: Npc = Npc(
            groups=[all_sprites, all_npcs, all_colliders],
            img_filename=gr_npc_spec['img_filename'],
            x=gr_npc_spec['x'],
            y=gr_npc_spec['y'],
            direction=gr_npc_spec['d'],
            speed=gr_npc_spec['s'],
            angle=gr_npc_spec['a'],
            angular_vel=gr_npc_spec['av'],
            e_spec=gr_e_spec,
        )
    npcs[gr_npc_spec['name']] = npc  # Key off name or instance id. name should be unique

# INSTANITATE PROP SPRITES
props: dict[str, Prop] = {}
for i, generated_prop_spec in enumerate(generated_prop_specs):
    generated_prop_spec['instance_id'] = i  # The instance id inside the class is totally different. ? Yes. TODO: Clarify.
    load_image(
            filename=generated_prop_spec['img_filename'],
            flip=generated_prop_spec['flip'],
            resize=generated_prop_spec['resize'],
            width=generated_prop_spec['w'],
            height=generated_prop_spec['h'],
        )
    prop: Prop = Prop(
            groups=[all_sprites, all_props],
            img_filename=generated_prop_spec['img_filename'],
            x=generated_prop_spec['x'],
            y=generated_prop_spec['y'],
            angle=generated_prop_spec['a'],
        )
    props[generated_prop_spec['name']] = prop  # Key off name or instance id. name should be unique


# LOAD SURFACE CACHE WITH WEAPON DATA. (No Weapons have been instantiated at this point. Just loading the cache.)
for i, gr_weapon_spec in enumerate(ent.weapon_specs):
    gr_weapon_spec['instance_id'] = i
    load_image(
            filename=gr_weapon_spec['img_filename'],
            flip=gr_weapon_spec['flip'],
            resize=gr_weapon_spec['resize'],
            width=gr_weapon_spec['w'],
            height=gr_weapon_spec['h'],
        )


# LOAD ANIMATION CACHE WITH FRAMES DATA. (No Animations have been instantiated at this point. Just loading the cache.)
for i, gr_anim_spec in enumerate(ent.anim_specs):
    gr_anim_spec['instance_id'] = i
    load_anim_frames(
            frames_dir=gr_anim_spec['frames_dir'],
            flip=gr_anim_spec['flip'],
            resize=gr_anim_spec['resize'],
            width=gr_anim_spec['w'],
            height=gr_anim_spec['h'],
        )


# ###############################################    MAIN EXECUTION    #################################################

if not __name__ == '__main__':
    print("PyGameFun main.py has been imported. Some initialization has been performed. "
        "Main execution will not be started. Normally this file is executed as the app entry point and not imported.")
    sys.exit(0)

if cfg.DEBUG:
    bg_surface = pygame.Surface((cfg.SCREEN_WIDTH, cfg.SCREEN_HEIGHT))
    bg_surface.fill(cfg.BGCOLOR)
else:
    bg_surface = pygame.image.load(os.path.join(cfg.ASSET_PATH, cfg.BGIMG))

running: bool = True
ephase: tuple[str, int] | None = None
g_ephase_name: str | None = None
g_score: int = 1776  # Normally 0. During development with continuous testing, starting at '9876'.


ephase_count: int = 0  # 0, not None since we will likly first/always do an arithmetic check on it, not an existence check.
clock = pygame.time.Clock()

# CUSTOM EVENTS - Random meatballs
meatball_event = pygame.event.custom_type()
pygame.time.set_timer(meatball_event, cfg.MEATBALL_SPAWN_TIME_MIN + cfg.MEATBALL_SPAWN_TIME_RANGE)
# TODO: Meatball spawn time with current timer is only set randomly once at game start. MAKE IT VARY ALL THE TIME.
e_spec_meatball = composed_enviro_spec(ent.weapon_specs[cfg.PLAYER_MAIN_WEAPON_INDEX])

#   * * * * * * * * * * * * * * * * * * * * * * * *
#   * * * * * * * *    MAIN LOOP    * * * * * * * *
#   * * * * * * * * * * * * * * * * * * * * * * * *
while running:
    gr_delta_time = clock.tick(cfg.TICKRATE) / 1000  # Seconds elapsed for a single frame (e.g. - 60 Frm/sec = 0.017 sec/Frm)


    # ##################################################    INPUT    ###################################################

    for event in pygame.event.get():  # Check all new events since the last main loop iteration
        if event.type == pygame.QUIT:
            running = False
        if event.type == meatball_event:
            event_meatball(groups=new_meatballs_groups, e_spec_meatball=e_spec_meatball)


    # #######################################    ENVIRONMENT PHASE PROCESSING    #######################################

    # We rotate this list of tuples by popping off the left (next-in-line/first-in) and appending back onto the right
    # (end-of-line/recently-added).
    if ephase is None:
        ephase = cfg.ENVIRO_PHASES[0]
        g_ephase_name = ephase[0]
        ephase_count = ephase[1]
        cut_ephase = cfg.ENVIRO_PHASES.pop(0)  # Pop one off the left.
        cfg.ENVIRO_PHASES.append(cut_ephase)  # Stick it back on the right, and we'll use it for its specified duration.
    else:
        ephase_count -= 1  # Decrement the counter for the current ephase while we use it for its specified duration.
        if ephase_count < 1:
            ephase = None


    # #################################################    UPDATE    ###################################################

    all_props.update(gr_delta_time, g_ephase_name)
    all_npcs.update(gr_delta_time, g_ephase_name)
    all_players.update(gr_delta_time, g_ephase_name)
    all_greenballs.update(gr_delta_time, g_ephase_name)  # Must update GreenBalls (Weapons) AFTER Player since Player creates Weapons during Player update.
    all_meatballs.update(gr_delta_time, g_ephase_name)


    # ###############################################    COLLISIONS    #################################################

    if players['buck0'].rect.collidepoint(pygame.mouse.get_pos()):  # Rect collision example. Mainly we will use sprite collisions, often using collide_mask.
        print("BOINGGGGGGG!!")

    for greenball in all_greenballs:
        # PyCharm Warning, POSSIBLY FALSE, on: "pygame.sprite.collide_mas" callback argument.
        # Expected type '(_SpriteSupportsGroup | Any, _TSprite2) -> Any | None'
        # (matched generic type '(_TSprite ≤: _SpriteSupportsGroup, _TSprite2 ≤: _SpriteSupportsGroup) -> Any | None'),
        # got '(left: _HasImageAndRect | _HasMaskAndRect, right: _HasImageAndRect | _HasMaskAndRect) -> tuple[int, int] | None' instead
        # NOTE: MyPy does not complain about this, only PyCharm. I have had other false warnings like this and some went away with PyCharm upgrades.
        greenball_col_sprites = pygame.sprite.spritecollide(greenball, all_meatballs, True, pygame.sprite.collide_mask)
        if greenball_col_sprites:
            for col in greenball_col_sprites:
                g_score += 1  # g_ variable from outer scope. We do not need 'global' keyword. Limited use of these.
                print("                   *  *  *  BOOM!  *  *  *")
                greenball.kill()


    # ##################################################    DRAW    ####################################################

    # REDRAW THE BACKGROUND
    if cfg.ACID_MODE is False:
        display_surface.blit(bg_surface, (0, 0))

    # IN ORDER OF DESIRED VISIBILITY-PRECEDENCE:
    all_props.draw(display_surface)
    all_npcs.draw(display_surface)
    all_meatballs.draw(display_surface)
    all_greenballs.draw(display_surface)

    # SCOREBOARD
    if cfg.SCR:
        update_and_draw_scoreboard(display_surface, scoreboard_font, g_score)

    # PLAYER(s)
    all_players.draw(display_surface)

    pygame.display.flip()  # Similar to update but not entire screen. TODO: Clarify
    # TODO: The tutorial has now gone back to using .update() at some point. Again, need to clarify and -> use best one.


#   - * - * - * - * - * - * - * - * - * - * - * - * -
#   - * - * - * -     END MAIN LOOP     - * - * - * -
#   - * - * - * - * - * - * - * - * - * - * - * - * -


pygame.quit()


##
#


# ###################################################    NOTES    ######################################################

# PYGAME-CE DOCS:
# https://pyga.me/docs/

# Abstract Base Classes - Geeks Article:
# https://www.geeksforgeeks.org/abstract-classes-in-python/

# Abstract Base Classes - Python.Org:
# https://docs.python.org/3/library/abc.html


##
#
